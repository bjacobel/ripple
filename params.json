{"name":"Ripple","tagline":"Ripple is a REST API framework for the Go programming language. Demo is available below:","body":"# Ripple, a REST API framework for Go #\r\n\r\nRipple is a simple, yet flexible, REST API framework for the Go language (golang).\r\n\r\nSince building REST APIs often involves a lot of boiler plate code (building routes, handling GET, POST, etc. for each route), the framework attempts to simplify this by making assumptions about the way REST APIs are usually structured. The framework is flexible though, so if the defaults get in the way, they can be changed.\r\n\r\n# Installation #\r\n\r\nTo install the library, clone this git directory:\r\n\r\n    git clone https://github.com/laurent22/ripple.git\r\n\r\nand import it in your main Go file using `import ./ripple`\r\n\r\n# Demo #\r\n\r\nA simple todo demo is available there: [https://github.com/laurent22/ripple-demo](https://github.com/laurent22/ripple-demo)\r\n\r\n# Usage #\r\n\r\nHave a look at [demo/demo.go](demo/demo.go) and [demo/demo_client.go](demo/demo_client.go) for a simple example of a REST API application. \r\n\r\nIn general, the steps to build a REST application are as follow:\r\n\r\n``` go\r\npackage main\r\n\r\nimport (\r\n\t\"./ripple\"\r\n\t\"./controllers\"\r\n\t\"net/http\"\r\n)\r\n\r\nfunc main() {\t\r\n\t// Build the REST application\r\n\t\r\n\tapp := ripple.NewApplication()\r\n\t\r\n\t// Create a controller and register it. Any number of controllers\r\n\t// can be registered that way.\r\n\t\r\n\tuserController := rippledemo.NewUserController()\r\n\tapp.RegisterController(\"users\", userController)\r\n\t\r\n\t// Setup the routes. The special patterns `_controller` will automatically match\r\n\t// an existing controller, as defined above. Likewise, `_action` will match any \r\n\t// existing action.\r\n\t\r\n\tapp.AddRoute(ripple.Route{ Pattern: \":_controller/:id/:_action\" })\r\n\tapp.AddRoute(ripple.Route{ Pattern: \":_controller/:id/\" })\r\n\tapp.AddRoute(ripple.Route{ Pattern: \":_controller\" })\r\n\t\r\n\t// Start the server\r\n\t\r\n\thttp.ListenAndServe(\":8080\", app)\r\n}\r\n```\r\n\r\n## Application ##\r\n\r\nA Ripple application implements the [net.http Handler interface](http://golang.org/pkg/net/http/#Handler) and thus can be used with any Go server function that accepts this interface, including `ListenAndServe` or `ListenAndServeTLS`. To build a new application, call:\r\n\r\n``` go\r\napp := ripple.NewApplication()\r\n```\r\n\r\nThen, after having setup the controllers and routes (see below), call:\r\n\r\n``` go\r\nhttp.ListenAndServe(\":8080\", app)\r\n```\r\n    \r\nThis will create a REST API on `http://localhost:8080`\r\n\r\nRipple can also be used along other HTTP servers using `http.HandleFunc()` and accessing the `ServeHTTP()` function directly. For instance, to serve an HTML5/JS app under \"/app\" and the REST API under \"/api\", the following could be done:\r\n\r\n``` go\r\n// Handle the HTML5 app\r\nhttp.HandleFunc(\"/app/\", someHandleFunc)\r\n\r\n// Handle the REST API\t\r\napp.SetBaseUrl(\"/api/\")\r\nhttp.HandleFunc(\"/api/\", app.ServeHTTP) // Use the ServeHTTP function directly\r\n\r\n// Start the server\r\nhttp.ListenAndServe(\":8080\", nil)\r\n```\r\n\r\nThen the REST API will be at `http://localhost/api/:8080`, while the web application will be at `http://localhost/app/:8080`.\r\n\r\n## Controllers ##\r\n\r\nA Ripple controller is a `struct` with functions that handle the GET, POST, PUT, etc. HTTP methods (custom HTTP methods are also supported). The mapping between URLs and controller functions is done via routes (see below). Each function must start with the method name, followed by the (optional) action name. Each function receives a `ripple.Context` object that provides access to the full HTTP request, as well as the optional parameters. It also allows responding to the request. The code below shows a very simple controller that handles a GET method:\r\n\r\n``` go\r\ntype UserController struct {}\r\n\r\nfunc (this *UserController) Get(ctx *ripple.Context) {\r\n\t// Get the user ID:\r\n\tuserId, _ := strconv.Atoi(ctx.Params[\"id\"])\r\n\tif userId > 0 {\r\n\t\t// If a user ID is provided, we return the user with this ID.\r\n\t\tctx.Response.Body = this.userCollection.Get(userId)\r\n\t} else {\r\n\t\t// If no user ID is provided, we return all the users.\r\n\t\tctx.Response.Body = this.userCollection.GetAll()\r\n\t}\r\n}\r\n```\r\n\r\nIn the above code, `ctx.Params[\"id\"]` is used to retrieve the user ID, the response is provided by setting `ctx.Response.Body`. The body will automatically be serialized to JSON.\r\n\r\nTo handle the POST method, you would write something like this:\r\n\r\n``` go\r\nfunc (this *UserController) Post(ctx *ripple.Context) {\r\n\tbody, _ := ioutil.ReadAll(ctx.Request.Body)\r\n\tvar user rippledemo.UserModel\r\n\tjson.Unmarshal(body, &user)\r\n\tctx.Response.Body = this.userCollection.Add(user)\r\n}\r\n```\r\n\r\nFinally, more complex actions can be created. For example, this kind of function can be created to handle a REST URL such as `/users/123/friends`:\r\n\r\n``` go\r\nfunc (this *UserController) GetFriends(ctx *ripple.Context) {\r\n\tuserId, _ := strconv.Atoi(ctx.Params[\"id\"])\r\n\tvar output []rippledemo.UserModel\r\n\tfor _, d := range this.friends {\r\n\t\tif d.UserId1 == userId {\r\n\t\t\toutput = append(output, this.userCollection.Get(d.UserId2))\r\n\t\t} else if d.UserId2 == userId {\r\n\t\t\toutput = append(output, this.userCollection.Get(d.UserId1))\r\n\t\t}\r\n\t} \r\n\tctx.Response.Body = output\r\n}\r\n```\r\n\r\n## Routes ##\r\n\r\nThe routes map a given URL to a given controller / action. Before being used in a route, the controllers must first be registered:\r\n\r\n``` go\r\n// Create some example controllers:\r\n\r\nuserController = new(UserController)\r\nimageController = new(ImageController)\r\n\r\n// And register them:\r\n\r\napp.RegisterController(\"users\", userController)\r\napp.RegisterController(\"images\", imageController)\r\n```\r\n\r\nThen the routes can be created:\r\n\r\n``` go\r\napp.AddRoute(ripple.Route{ Pattern: \":_controller/:id/:_action\" })\r\napp.AddRoute(ripple.Route{ Pattern: \":_controller/:id/\" })\r\napp.AddRoute(ripple.Route{ Pattern: \":_controller\" })\r\n```\r\n\r\nParameters can be defined by prefixing them with `:`; they are then accessible from the context object via `ctx.Params[\"id\"]`.\r\n\r\nRoute patterns also accept two special parameters:\r\n\r\n* `_controller`: Match any registered controller.\r\n* `_action`: Match any existing controller action.\r\n\r\nFor example, the routes above would match URLs such as \"users/123\", \"images/7\", \"images/456/metadata\", etc. You do not need to specify the supported HTTP methods - whether a method is supported or not is implied from the controller functions. For instance, if the controller has a GetMetadata method, then `GET images/456/metadata` is automatically supported. Likewise, if it does *not* have a `DeleteMetadata` method, `DELETE images/456/metadata` will *not* be supported.\r\n\r\nRouting can be as flexible as needed. If the automatic mapping of `_controller` and `_action` doesn't do the job, it is possible to explicitly specify the controller and action. For example:\r\n\r\n``` go\r\napp.AddRoute(Route{ Pattern: \"some/very/custom/url\", Controller: \"users\", Action: \"example\" })\r\n```\r\n\t\r\nWith the above route, doing `GET some/very/custom/url` would call `UserController::GetExample`\r\n\r\n## Models? ##\r\n\r\nRipple does not have built-in support for models since data storage can vary a lot from one application to another. For an example on how to connect a controller to a model, see [demo/controllers/users.go](demo/controllers/users.go) and [demo/models/user.go](demo/models/user.go). Usually, you would inject a database connection or other data source into the controller then use that from the various actions.\r\n\r\n# Testing ##\r\n\r\nRipple is built with testability in mind. The whole framework is fully unit tested, and applications built with the framework can also be easily unit tested. Each controller method takes a `ripple.Context` object as parameter, which can be mocked for unit testing. The framework also exposes the `Application::Dispatch` method, which can be used to test the response for a given HTTP request.\r\n\r\n# Ripple API reference ##\r\n\r\nSee the [Ripple GoDoc reference](http://godoc.org/github.com/laurent22/ripple) for more information.\r\n\r\n# License #\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2013 Laurent Cozic\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}